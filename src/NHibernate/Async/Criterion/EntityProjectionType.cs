//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by AsyncGenerator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------


using System;
using System.Data.Common;
using NHibernate.Engine;
using NHibernate.Event;
using NHibernate.Persister.Entity;
using NHibernate.Type;

namespace NHibernate.Criterion
{
	using System.Threading.Tasks;
	using System.Threading;
	internal partial class EntityProjectionType : ManyToOneType, IType
	{

		Task<object> IType.NullSafeGetAsync(DbDataReader rs, string[] names, ISessionImplementor session, object owner, CancellationToken cancellationToken)
		{
			if (cancellationToken.IsCancellationRequested)
			{
				return Task.FromCanceled<object>(cancellationToken);
			}
			//names parameter is ignored (taken from projection)
			return NullSafeGetAsync(rs, string.Empty, session, owner, cancellationToken);
		}

		public override async Task<object> NullSafeGetAsync(DbDataReader rs, string name, ISessionImplementor session, object owner, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			var identifier = await (_projection.Persister.IdentifierType.NullSafeGetAsync(rs, _projection.IdentifierColumnAliases, session, null, cancellationToken)).ConfigureAwait(false);

			if (identifier == null)
			{
				return null;
			}

			return _projection.Lazy
				? await (ResolveIdentifierAsync(identifier, session, cancellationToken)).ConfigureAwait(false)
				: await (GetInitializedEntityFromProjectionAsync(rs, session, identifier, cancellationToken)).ConfigureAwait(false);
		}

		private async Task<object> GetInitializedEntityFromProjectionAsync(DbDataReader rs, ISessionImplementor session, object identifier, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			var entity = await (CreateInitializedEntityAsync(
				rs,
				session,
				_projection.Persister,
				identifier,
				_projection.PropertyColumnAliases,
				LockMode.None,
				_projection.FetchLazyProperties,
				_projection.IsReadOnly, cancellationToken)).ConfigureAwait(false);

			return entity;
		}

		private static async Task<object> CreateInitializedEntityAsync(DbDataReader rs, ISessionImplementor session, IQueryable persister, object identifier, string[][] propertyAliases, LockMode lockMode, bool fetchLazyProperties, bool readOnly, CancellationToken cancellationToken)
		{
			cancellationToken.ThrowIfCancellationRequested();
			var eventSource = session as IEventSource;
			PostLoadEvent postLoadEvent = null;
			PreLoadEvent preLoadEvent = null;
			object entity;
			if (eventSource != null)
			{
				preLoadEvent = new PreLoadEvent(eventSource);
				postLoadEvent = new PostLoadEvent(eventSource);
				entity = eventSource.Instantiate(persister, identifier);
			}
			else
			{
				entity = session.Instantiate(persister.EntityName, identifier);
			}

			TwoPhaseLoad.AddUninitializedEntity(
				session.GenerateEntityKey(identifier, persister),
				entity,
				persister,
				lockMode,
				!fetchLazyProperties,
				session);

			var hydrated = await (persister.HydrateAsync(
				rs,
				identifier,
				entity,
				persister,
				propertyAliases,
				fetchLazyProperties,
				session, cancellationToken)).ConfigureAwait(false);

			TwoPhaseLoad.PostHydrate(persister, identifier, hydrated, null, entity, lockMode, !fetchLazyProperties, session);
			await (TwoPhaseLoad.InitializeEntityAsync(entity, readOnly, session, preLoadEvent, postLoadEvent, cancellationToken)).ConfigureAwait(false);
			return entity;
		}
	}
}
